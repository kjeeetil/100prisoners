<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual 100 Prisoners: The Loops</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #1e1e24; color: #fff; max-width: 950px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; color: #f1c40f; }
        
        .controls { background: #2b2b36; padding: 20px; border-radius: 8px; display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px; align-items: center; justify-content: center; }
        button, select, input { padding: 10px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; transition: 0.2s; font-size: 14px; }
        button { background: #3498db; color: white; }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.run-slow { background: #e67e22; }
        button.run-room { background: #9b59b6; }
        button.run-sim { background: #2ecc71; }
        button.reset { background: #e74c3c; margin-left: auto; }
        
        .tracker { background: #2b2b36; padding: 15px; border-radius: 8px; font-size: 16px; text-align: center; min-height: 25px; margin-bottom: 20px; border-left: 5px solid #f1c40f; }
        
        .grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 8px; margin-bottom: 20px; }
        
        /* Box View */
        .box { 
            aspect-ratio: 1; background: #444; border-radius: 6px; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; font-size: 14px; position: relative;
            transition: all 0.15s; border: 2px solid transparent;
        }
        .box .label { color: #aaa; font-size: 10px; margin-bottom: 2px; }
        .box .slip { font-size: 18px; font-weight: bold; opacity: 0; transform: scale(0.5); transition: all 0.15s; }
        .box.open { background: #fff; color: #000; }
        .box.open .label { color: #888; }
        .box.open .slip { opacity: 1; transform: scale(1); }
        .box.active { border-color: #f1c40f; box-shadow: 0 0 10px #f1c40f; transform: scale(1.05); z-index: 10; }
        .box.success { border-color: #2ecc71; background: #e8f8f5; }
        
        /* Prisoner View */
        .prisoner {
            aspect-ratio: 1; background: #333; border-radius: 6px; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; font-size: 14px; position: relative;
            transition: all 0.1s; border: 2px solid transparent; color: #555; cursor: pointer;
        }
        
        /* Hover State for Shared Loops */
        .prisoner.on-same-loop {
            box-shadow: 0 0 15px #3498db;
            border-color: #3498db;
            transform: scale(1.1);
            z-index: 5;
            background: #2c3e50;
        }
        .prisoner.on-same-loop .label { color: #ccc; }
        .prisoner.on-same-loop .tries { color: #fff; opacity: 0.5; }

        .prisoner:hover { filter: brightness(1.3); border-color: #fff; }
        .prisoner .label { font-size: 10px; margin-bottom: 2px; color: #777; pointer-events: none; }
        .prisoner .tries { font-size: 20px; font-weight: bold; opacity: 0; pointer-events: none; }
        
        .prisoner.success { background: #2ecc71; color: #1e1e24; border-color: #27ae60; box-shadow: 0 0 8px rgba(46,204,113,0.4); }
        .prisoner.success .label { color: rgba(0,0,0,0.5); }
        .prisoner.success .tries { opacity: 1; }
        
        .prisoner.fail { background: #e74c3c; color: #fff; border-color: #c0392b; box-shadow: 0 0 10px rgba(231,76,60,0.6); transform: scale(1.1); z-index: 10;}
        .prisoner.fail .label { color: rgba(255,255,255,0.7); }
        .prisoner.fail .tries { opacity: 1; }
        .prisoner.dead { opacity: 0.3; pointer-events: none; } 

        .dashboard { display: grid; grid-template-columns: 1fr 2fr; gap: 20px; margin-bottom: 20px; }
        .stats { display: flex; flex-direction: column; gap: 10px; background: #2b2b36; padding: 20px; border-radius: 8px; justify-content: center; }
        .stats span { font-size: 16px; color: #ccc;}
        .stats strong { color: #fff; font-size: 20px; display: block; }
        .stats .highlight { color: #f1c40f; font-size: 24px;}
        .chart-container { background: #2b2b36; padding: 15px; border-radius: 8px; position: relative; height: 250px; }

        /* Modal & Visual Loop Styles */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; align-items: center; justify-content: center; }
        .modal-content { background: #2b2b36; padding: 25px; border-radius: 8px; max-width: 650px; width: 90%; max-height: 80vh; overflow-y: auto; border: 2px solid #f1c40f; position: relative; }
        .close-btn { position: absolute; top: 15px; right: 20px; cursor: pointer; color: #e74c3c; font-weight: bold; font-size: 24px; transition: 0.2s; }
        .close-btn:hover { color: #c0392b; transform: scale(1.1); }
        .path-step { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #444; font-size: 14px; }
        .modal-content h2 { margin-top: 0; color: #f1c40f; border-bottom: 1px solid #555; padding-bottom: 10px; }
        
        .loop-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding: 20px 0; align-items: center;}
        .loop-node { width: 45px; height: 45px; background: #3498db; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; position: relative; flex-shrink: 0;}
        .loop-node.target { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; transform: scale(1.1); z-index: 2; border: 2px solid #fff;}
        .loop-arrow { display: flex; align-items: center; color: #aaa; font-size: 18px; }
        .loop-summary { text-align: center; margin-bottom: 10px; color: #ccc; font-size: 15px;}
    </style>
</head>
<body>

    <h1>The 100 Prisoners Dilemma: Loop Visualizer</h1>

    <div class="controls">
        <select id="strategy">
            <option value="cycle">Cycle Following (Smart)</option>
            <option value="random">Random Choice (Naive)</option>
            <option value="fixed">Fixed Boxes 0-49 (Static)</option>
        </select>
        <button class="run-slow" id="btnSlow">Animate 1 Prisoner</button>
        <button class="run-room" id="btnRoom">Animate 1 Room</button>
        
        <input type="number" id="simCount" value="1000" style="width: 80px;" min="1">
        <button class="run-sim" id="btnSim">Simulate Batch</button>
        <button class="reset" id="btnReset">Reset All Data</button>
    </div>

    <div class="tracker" id="tracker">Hover over prisoners to see their shared loops. Run Cycle strategy and click to view the loop visualization.</div>

    <div class="grid" id="grid"></div>

    <div class="dashboard">
        <div class="stats">
            <div style="border-bottom: 1px solid #555; padding-bottom: 10px; margin-bottom: 5px;">
                <strong style="color: #3498db; font-size: 18px;">Active Session (<span id="activeStratLabel">Cycle</span>)</strong>
                <span>Rooms Run: <strong id="statTrials">0</strong></span>
                <span>Win Rate: <strong class="highlight" id="statRate">0.00%</strong></span>
            </div>
            <div>
                <strong style="font-size: 14px; color: #aaa;">Global Wins</strong>
                <span style="font-size: 14px;">Cycle: <span id="globalCycle" style="color:#fff">0</span> | Random: <span id="globalRandom" style="color:#fff">0</span> | Fixed: <span id="globalFixed" style="color:#fff">0</span></span>
            </div>
        </div>
        <div class="chart-container">
            <canvas id="probChart"></canvas>
        </div>
    </div>
    
    <div class="chart-container" style="height: 250px;">
        <canvas id="histChart"></canvas>
    </div>

    <div class="modal" id="sequenceModal">
        <div class="modal-content">
            <span class="close-btn" id="closeModal">&times;</span>
            <div id="sequenceContent"></div>
        </div>
    </div>

    <script>
        const grid = document.getElementById('grid');
        const tracker = document.getElementById('tracker');
        const sequenceModal = document.getElementById('sequenceModal');
        let boxes = [];
        let isAnimating = false;
        let prisonerPaths = {}; 
        let currentStrategy = 'cycle';
        
        let prisonerCycleMap = {};

        let sessionTrials = 0;
        let sessionWins = 0;
        
        let globalStats = { cycle: { trials: 0, wins: 0 }, random: { trials: 0, wins: 0 }, fixed: { trials: 0, wins: 0 } };
        let failureCounts = { cycle: Array(100).fill(0), random: Array(100).fill(0), fixed: Array(100).fill(0) };

        // Charts Setup
        const ctxProb = document.getElementById('probChart').getContext('2d');
        let probChart = new Chart(ctxProb, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [
                    { label: 'Session Win Rate (%)', data: [], borderColor: '#2ecc71', backgroundColor: 'rgba(46, 204, 113, 0.1)', borderWidth: 2, pointRadius: 0, fill: true, tension: 0.1 }, 
                    { label: 'Theoretical (~31.18%)', data: [], borderColor: '#f1c40f', borderWidth: 1, borderDash: [5, 5], pointRadius: 0, fill: false }
                ] 
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: 100, grid: { color: '#444' }, ticks: { color: '#aaa' } }, x: { grid: { color: '#444' }, ticks: { color: '#aaa' } } }, plugins: { legend: { labels: { color: '#fff' } } } }
        });

        const ctxHist = document.getElementById('histChart').getContext('2d');
        let histChart = new Chart(ctxHist, {
            type: 'bar',
            data: { 
                labels: Array.from({length: 100}, (_, i) => `P${i}`), 
                datasets: [
                    { label: 'Cycle Strategy (%)', data: [], backgroundColor: '#3498db', categoryPercentage: 0.8, barPercentage: 0.9 }, 
                    { label: 'Random Strategy (%)', data: [], backgroundColor: '#e67e22', categoryPercentage: 0.8, barPercentage: 0.9 }, 
                    { label: 'Fixed Strategy (%)', data: [], backgroundColor: '#9b59b6', categoryPercentage: 0.8, barPercentage: 0.9 }
                ] 
            },
            options: { 
                responsive: true, maintainAspectRatio: false, 
                scales: { 
                    y: { beginAtZero: true, grid: { color: '#444' }, ticks: { color: '#aaa', callback: function(value) { return value + "%" } }, title: { display: true, text: '% of Rooms that failed at this Prisoner', color: '#fff' } }, 
                    x: { grid: { display: false }, ticks: { color: '#aaa', maxRotation: 90, minRotation: 90, font: {size: 9} } } 
                }, 
                plugins: { legend: { labels: { color: '#fff' } }, tooltip: { callbacks: { label: function(context) { return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%'; } } } } 
            }
        });

        function shuffleBoxes() {
            boxes = Array.from({length: 100}, (_, i) => i);
            for (let i = boxes.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [boxes[i], boxes[j]] = [boxes[j], boxes[i]];
            }
            mapCycles();
        }

        function mapCycles() {
            prisonerCycleMap = {};
            let visited = new Set();
            for (let i = 0; i < 100; i++) {
                if (visited.has(i)) continue;
                
                let currentCycle = [];
                let curr = i;
                while (!visited.has(curr)) {
                    visited.add(curr);
                    currentCycle.push(curr);
                    curr = boxes[curr];
                }
                currentCycle.forEach(pId => {
                    prisonerCycleMap[pId] = currentCycle;
                });
            }
        }

        function renderBoxGrid() {
            grid.innerHTML = '';
            for (let i = 0; i < 100; i++) {
                grid.innerHTML += `<div class="box" id="box-${i}"><div class="label">Box ${i}</div><div class="slip">${boxes[i]}</div></div>`;
            }
        }

        function renderPrisonerGrid() {
            grid.innerHTML = '';
            for (let i = 0; i < 100; i++) {
                grid.innerHTML += `<div class="prisoner" id="p-${i}"><div class="label">Prisoner ${i}</div><div class="tries">0</div></div>`;
            }
        }

        const sleep = ms => new Promise(r => setTimeout(r, ms));

        function resetSessionChart() {
            sessionTrials = 0; 
            sessionWins = 0;
            probChart.data.labels = []; 
            probChart.data.datasets[0].data = []; 
            probChart.data.datasets[1].data = [];
            probChart.update(); 
            updateDashboard();
        }

        document.getElementById('strategy').addEventListener('change', (e) => {
            const labelMap = { 'cycle': 'Cycle', 'random': 'Random', 'fixed': 'Fixed' };
            document.getElementById('activeStratLabel').textContent = labelMap[e.target.value];
            currentStrategy = e.target.value;
            resetSessionChart();
        });

        function updateDashboard(updateCharts = true) {
            document.getElementById('statTrials').textContent = sessionTrials;
            document.getElementById('statRate').textContent = sessionTrials === 0 ? "0.00%" : ((sessionWins / sessionTrials) * 100).toFixed(2) + '%';
            
            document.getElementById('globalCycle').textContent = globalStats.cycle.wins;
            document.getElementById('globalRandom').textContent = globalStats.random.wins;
            document.getElementById('globalFixed').textContent = globalStats.fixed.wins;
            
            if (updateCharts && sessionTrials > 0) {
                probChart.data.labels.push(sessionTrials);
                probChart.data.datasets[0].data.push((sessionWins / sessionTrials) * 100);
                probChart.data.datasets[1].data.push(31.18);
                probChart.update();
                
                ['cycle', 'random', 'fixed'].forEach((strat, idx) => {
                    const stratTrials = globalStats[strat].trials;
                    histChart.data.datasets[idx].data = failureCounts[strat].map(fails => stratTrials > 0 ? (fails / stratTrials * 100) : 0);
                });
                histChart.update();
            }
        }

        async function animateOnePrisoner(prisonerId, strategy) {
             if (isAnimating) return; 
             isAnimating = true; 
             shuffleBoxes(); 
             renderBoxGrid();
             tracker.innerHTML = `Prisoner ${prisonerId} looking for slip <strong>#${prisonerId}</strong>.`; 
             await sleep(400);
             
             let nextBox = prisonerId; 
             let available = Array.from({length: 100}, (_, i) => i); 
             let found = false;
             
             for (let attempt = 1; attempt <= 50; attempt++) {
                 if (strategy === 'random') {
                     nextBox = available.splice(Math.floor(Math.random() * available.length), 1)[0];
                 } else if (strategy === 'fixed') {
                     nextBox = attempt - 1;
                 }
                 
                 const boxEl = document.getElementById(`box-${nextBox}`); 
                 boxEl.classList.add('active'); 
                 await sleep(80);
                 
                 boxEl.classList.remove('active'); 
                 boxEl.classList.add('open');
                 
                 const slip = boxes[nextBox];
                 if (slip === prisonerId) { 
                     boxEl.classList.add('success'); 
                     tracker.innerHTML = `Attempt ${attempt}: Found slip <strong>#${slip}</strong>! Survived!`; 
                     found = true; 
                     break; 
                 } else { 
                     if (strategy === 'cycle') nextBox = slip; 
                 } 
                 await sleep(150);
             }
             if (!found) tracker.innerHTML = `<span style="color:#e74c3c">Failed in 50 tries. Executed.</span>`; 
             isAnimating = false;
        }

        async function animateRoomSequentially(strategy) {
            if (isAnimating) return; 
            isAnimating = true; 
            shuffleBoxes(); 
            renderPrisonerGrid(); 
            prisonerPaths = {};
            
            if (strategy === 'cycle') {
                tracker.innerHTML = `Starting room sequence... Hover over prisoners to see shared loops.`; 
            } else {
                tracker.innerHTML = `Starting room sequence...`;
            }
            await sleep(400);
            
            let allSurvived = true;
            
            for (let p = 0; p < 100; p++) {
                let found = false; 
                let nextBox = p; 
                let available = Array.from({length: 100}, (_, i) => i); 
                let tries = 0; 
                prisonerPaths[p] = [];
                
                for (let attempt = 1; attempt <= 50; attempt++) {
                    tries = attempt;
                    if (strategy === 'random') {
                        nextBox = available.splice(Math.floor(Math.random() * available.length), 1)[0];
                    } else if (strategy === 'fixed') {
                        nextBox = attempt - 1;
                    }
                    
                    let slip = boxes[nextBox]; 
                    prisonerPaths[p].push({ attempt, boxOpened: nextBox, slipFound: slip });
                    
                    if (slip === p) { found = true; break; } 
                    nextBox = slip;
                }
                
                const pCell = document.getElementById(`p-${p}`); 
                pCell.querySelector('.tries').textContent = tries;
                
                if (found) { 
                    pCell.classList.add('success'); 
                } else {
                    pCell.classList.add('fail'); 
                    pCell.querySelector('.tries').textContent = "X";
                    tracker.innerHTML = `<span style="color:#e74c3c">Prisoner ${p} failed! Everyone executed.</span>`; 
                    allSurvived = false;
                    failureCounts[strategy][p]++;
                    
                    for (let rest = p + 1; rest < 100; rest++) {
                        document.getElementById(`p-${rest}`).classList.add('dead');
                    }
                    break;
                } 
                await sleep(30);
            }
            
            sessionTrials++; 
            globalStats[strategy].trials++;
            
            if (allSurvived) { 
                tracker.innerHTML = `<span style="color:#2ecc71">All 100 survived! Click any prisoner to view their sequence.</span>`; 
                sessionWins++; 
                globalStats[strategy].wins++; 
            }
            
            updateDashboard(true); 
            isAnimating = false;
        }

        function runBatchSimulation(count) {
            if (isAnimating) return;
            const strategy = document.getElementById('strategy').value;
            const updateInterval = Math.max(1, Math.floor(count / 50));
            
            for (let i = 0; i < count; i++) {
                shuffleBoxes(); 
                let allSurvived = true;
                
                for (let p = 0; p < 100; p++) {
                    let found = false; 
                    let nextBox = p; 
                    let available = Array.from({length: 100}, (_, i) => i);
                    
                    for (let attempt = 0; attempt < 50; attempt++) {
                        if (strategy === 'random') {
                            nextBox = available.splice(Math.floor(Math.random() * available.length), 1)[0];
                        } else if (strategy === 'fixed') {
                            nextBox = attempt;
                        }
                        
                        let slip = boxes[nextBox]; 
                        if (slip === p) { found = true; break; } 
                        nextBox = slip;
                    }
                    if (!found) { 
                        allSurvived = false; 
                        failureCounts[strategy][p]++; 
                        break; 
                    }
                }
                
                sessionTrials++; 
                globalStats[strategy].trials++;
                if (allSurvived) { 
                    sessionWins++; 
                    globalStats[strategy].wins++; 
                }
                if (sessionTrials % updateInterval === 0 || i === count - 1) {
                    updateDashboard(true);
                }
            }
            tracker.innerHTML = `Ran ${count} simulations using ${strategy} strategy.`;
        }

        // --- Interaction Logic ---

        // Hover Highlighting Logic for Loops
        grid.addEventListener('mouseover', (e) => {
            // ONLY highlight the loops if we are actually using the Cycle strategy
            if (currentStrategy !== 'cycle') return; 

            const prisonerCell = e.target.closest('.prisoner');
            if (!prisonerCell) return;
            
            const pId = parseInt(prisonerCell.id.split('-')[1]);
            const cycle = prisonerCycleMap[pId];
            
            if (cycle) {
                cycle.forEach(id => {
                    const el = document.getElementById(`p-${id}`);
                    if (el) el.classList.add('on-same-loop');
                });
            }
        });

        grid.addEventListener('mouseout', (e) => {
            // Unconditionally remove the class when hovering off, just to be safe
            document.querySelectorAll('.prisoner.on-same-loop').forEach(el => el.classList.remove('on-same-loop'));
        });

        // Modal Box Logic (Visual Loop vs Text Log)
        grid.addEventListener('click', (e) => {
            if (isAnimating) return; 
            const prisonerCell = e.target.closest('.prisoner');
            if (!prisonerCell) return;
            
            const pId = parseInt(prisonerCell.id.split('-')[1]);
            let html = '';

            // Render Visual Loop for Cycle Strategy
            if (currentStrategy === 'cycle') {
                const cycle = prisonerCycleMap[pId];
                if (!cycle) return; 

                const length = cycle.length;
                const statusColor = length <= 50 ? '#2ecc71' : '#e74c3c';
                const statusText = length <= 50 ? 'Safe Loop' : 'Doomed Loop (>50)';

                html = `<h2>Prisoner ${pId} is on a <span style="color:${statusColor}">${statusText}</span> (Length: ${length})</h2>`;
                html += '<p class="loop-summary">Every prisoner below is trapped on this exact same carousel.</p>';
                html += '<div class="loop-container">';
                
                const startIndex = cycle.indexOf(pId);
                for(let i = 0; i < length; i++) {
                    const currentIndex = (startIndex + i) % length;
                    const nodeId = cycle[currentIndex];
                    const isTarget = nodeId === pId;
                    html += `<div class="loop-node ${isTarget ? 'target' : ''}">${nodeId}</div>`;
                    html += `<div class="loop-arrow">â†’</div>`;
                }
                
                html += `<div class="loop-node target">${pId}</div>`; 
                html += '</div>';

            } else {
                // Standard Text Path for Random/Fixed Strategies
                const path = prisonerPaths[pId];
                if (!path || path.length === 0) return; 
                
                html = `<h2>Prisoner ${pId}'s Draw Sequence (${currentStrategy})</h2>`;
                path.forEach(step => {
                    const isTarget = step.slipFound === pId;
                    const color = isTarget ? '#2ecc71' : '#fff';
                    html += `
                        <div class="path-step">
                            <span>Attempt ${step.attempt}: Opened Box <strong>${step.boxOpened}</strong></span>
                            <span style="color: ${color}">Found Slip <strong>${step.slipFound}</strong></span>
                        </div>`;
                });
            }

            document.getElementById('sequenceContent').innerHTML = html;
            sequenceModal.style.display = 'flex';
        });

        document.getElementById('closeModal').onclick = () => { sequenceModal.style.display = 'none'; };
        window.onclick = (event) => { if (event.target === sequenceModal) sequenceModal.style.display = 'none'; };

        // Buttons
        document.getElementById('btnSlow').onclick = () => animateOnePrisoner(Math.floor(Math.random() * 100), currentStrategy);
        document.getElementById('btnRoom').onclick = () => animateRoomSequentially(currentStrategy);
        document.getElementById('btnSim').onclick = () => runBatchSimulation(parseInt(document.getElementById('simCount').value));
        
        document.getElementById('btnReset').onclick = () => {
            if(isAnimating) return;
            globalStats = { cycle: { trials: 0, wins: 0 }, random: { trials: 0, wins: 0 }, fixed: { trials: 0, wins: 0 } };
            failureCounts = { cycle: Array(100).fill(0), random: Array(100).fill(0), fixed: Array(100).fill(0) };
            resetSessionChart();
            
            ['cycle', 'random', 'fixed'].forEach((strat, idx) => { histChart.data.datasets[idx].data = []; });
            histChart.update();
            
            tracker.innerHTML = "All data reset.";
            shuffleBoxes(); 
            renderBoxGrid(); 
            prisonerPaths = {}; 
        };

        // Initialize App
        shuffleBoxes();
        renderBoxGrid();
        updateDashboard(false);
    </script>
</body>
</html>